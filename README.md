# recommender-system
Recommender system based on library Implicit, ALS method

### Постановка проблемы 

Для музыкального с стримингового сервиса нужно выбрать наиболее подходящий вариант рекомендальено системы, которую относительно легко реализовать

#### Проведем небольшое исследование. Рассмотрим виды рекомендательных систем

##### Рекомендации на основе содержания

Содержание - это какие-то фичи, свойства объекта. Эти свойства и рекомендуются

Есть ряд проблем: 

* Фичи надо где-то брать. 
* Могут быть не заполнены, или заполнены неверно или 
* Фичи у разных объектов могут не пересекаться, все это вызывает сложности в использовании
* Особенности предметной области (для заполнения фичей может потребоваться привлечение экспертов)

Так Netflix когда-то хотели создать тегирование и деление на микрожанры, для этих целей им пришлось привлечь кучу специалистов. 

MovieLens дали возможность самим пользователям указывать теги, в итоге возникла проблема огромного количества тегов, причем часто одинаковых, но по-разному написанных

Примеры таких РС: 
* купил мужские носки, рекомендуем вам еще мужские трусы
* на кассе в пятерочке: товары по акции покупайте 

##### Коллаборативная фильтрация

Рекомендации строятся на основе поведения, на основе взаимодействия с объектами 
Фичи - кусочек лога действий пользователя с этим объектом. 

Плюсы:
* не нужно налаживать процесс извлечения фичей, пользователь сам все нам передает 
* не зависит от предметной области 
* используются данные о поведении пользователя и предсказываем тоже поведение

Минусы:
* сложно объяснять рекомендации (донести до пользователя почему это рекомендовано именно ему)
* проблема холодного старта (с новыми объектами пользователи еще не успели повзаимодействовать, а значит нет лога действий и нет фичей, на основе которого делается предсказание)
* нужно много данных (качество рекомендаций зависит от качества и объема данных)
* в итоге может получиться гигантская матрица, с которой потом будет трудно работать

##### Рекомендации на основе скрытых факторов

Отдельно выделяют рекомендательные системы на основе скрытых факторов
Это тоже коллаборативная фильтрация, в которой за счет математических моделей и скрытых факторов решается проблема размерности матриц

###### Методы 

* SVD (Singular Value Decomposition - Разложение по сингулярным значениям). Одним из главных недостатков метода - работает только для явной обратной связи от пользователя. Различия явного и неявного обсудим дальше. 
* PLSA (Probabilistic Latent Semantic Analysis - вероятностная тематическая модель представления текста на естественном языке)
* ALS (Alternating Least Squares - альтернативный метод наименьших квадратов), доступен как для явной, так и для неявной обратной связи

##### Гибридные рекомендательные системы

Из названия понятно, что эти модели совмещают в себе предыдущие варианты. 

То есть тут используются и фичи из рекомендательных систем на основе контента и результаты предсказания на основе коллаборативной фильтрации, могут быть использованы одновременно модели с явной и неявной обратной связью

В конце концов, скорее всего все приходят к гибридной модели, но пока я хочу остановиться ПОДРОБНЕЕ на ALS модели скрытых факторов 

##### Методы ALS (альтернативный метод наименьших квадратов)

Явная обратная связь - пользователь сам дает оценку (нравится / не нравится)

Проблемы:
* пользователь может взаимодействовать, но не ставить оценку 
* может ставить оценку по каким-то своим субъективным критериям
* может поставить оценку объекту, с которым не взаимодействовал

Неявная обратная связь - это обратная связь на основе поведения пользователя 

* сколько раз купил товар
* сколько раз прослушал песню
* сколько времени читал статью или смотрел видео-ролик

Если он не взаимодействовал с объектом - это не значит, что он ему не нравится, возможно, он просто не знает о его существовании или он для него слишком дорогой. 

Проблема:
* факт взаимодействия не значит, что объект понравился (послушал песню и возненавидел ее)
* факт взаимодействия не отражает степень -  насколько понравился / не понравился объект

количество / длительность взаимодействия по каждому объекту будет степенью уверенности (песня прослушанная 10 раз, скорее всего нравится больше, чем прослушанная 1 раз) 

###### Методы ALS (сокращение размерности)

Получается огромная матрица данных, с большим количеством объектов
Однако, эти объекты, как правило связаны между собой и отражают наши “вкусы” 

Важно оговориться, что вкусы здесь имеются в виду НЕ жанр или конкретный артист, а нечто, что не очень поддается интерпретации и логическому объяснению
Вот эти “вкусы” - это и есть фичи или скрытые факторы. 
Факторный анализ - связанные между собой объекты можно выделить в некий самостоятельный феномен, сократив размерность данных. 

###### Выделяют факторы и разбивают матрицу на 2
* users - фичи
* items - фичи

##### Что за наименьшие квадраты?

Простейший метод предсказания - линейная регрессия. 
Находят функцию, которая позволяет по значению одной переменной предсказать другую 

Ищут такую функцию, при которой  возведенные в квадрат ошибки модели минимальны

Так вот возможен обратный вариант, значения обеих переменных неизвестны, но найдена функция, для которой значения ошибок минимальны
От этой линии делая проекцию на оси x и y мы можем предсказать значения этих переменных. 
То есть ALS предсказывает для двух объектов, какова вероятность того, что они понравятся пользователю. 

##### Разреженность матрицы. Достоверность рекомендации

Проблемы:

В нашей гигантской матрице будет много нулей, то есть какой-то трек прослушал кто-то, а другие его не слушали
В моделях с явной обратной связью оценки стандартизируют данные, например, не может быть больше 5 или меньше 1, а у нас прослушиваний может быть от 0 до бесконечности

Умные дядьки из AT&T (вроде бы один из Facebook, второй из Spotify) предложили решить это с помощью двух переменных

p - предпочтение (нравится / не нравится) то есть категориальная шкала с двумя вариантами 1 и 0. Есть хотя бы одно взаимодействие с объектом p=1, нет - p=0

c - достоверность / уверенность, здесь появляется коэффициент масштабирования α, он может меняться и задается нами как параметр модели. В итоге достоверность рассчитывается как произведение α на r (то есть количество взаимодействий с объектом) + 1 

##### Как формируются рекомендации?
.
* Формируются векторы 
* user-фича (для каждого пользователя)
* item-фича (для каждого объекта) 

Используя косинусную меру сходства, то есть высчитав скалярное произведение векторов, можно сделать вывод, насколько они близки. 

Грубо говоря, здесь учитываетя острота угла между векторами. 

Аналогично коэффициенту корреляции значения находятся в интервале от -1 до +1, чем ближе к 1, тем сильнее связь

### Ну что ж, теперь можно посмотреть как это работает на примере библиотеки Implicit. 
